+++
title = '15. 三数之和'
date = 2024-04-29T22:19:48+08:00
draft = false

+++

## [题目](https://leetcode.cn/problems/3sum/description/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

## 解题思路

如果直接使用三重循环枚举三元组，时间复杂度为$O(n^3)$，还需要使用哈希表去重，得到不包含重复三元组的最终答案，又消耗了大量的空间。

如果令枚举的三元组`(a, b, c)` 满足`a ≤ b ≤ c`，保证了只有`(a, b, c) `这个顺序会被枚举到，而` (b, a, c)`、`(c, b, a)`等等这些不会，就不会产生重复。要实现这一点，可以将数组排序，随后使用普通的三重循环。

同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为

```csharp
[-1, -1, 0, 1, 2, 2]
 ^       ^  ^
```

以第一层循环为例，枚举过的一个三元组是`(-1, 0, 1)`，下一次枚举的元素也是-1，也会枚举到相同的三元组是`(-1, 0, 1)`。因此需要跳到下一个不相同的元素，也就是0。

此时时间复杂度依然是$O(n^3)$，可以发现，如果固定a，找到a + b + c = 0，当第二重循环往后枚举一个元素 b′ 时，由于 b′ > b，所以那么满足 a + b′ + c′ = 0的c′ 一定小于c，即 c′一定在c的左侧。因此可以将第二重和第三重循环用对撞指针实现。

当需要枚举数组中的两个元素时，如果发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从$O(n^2)$减少至 $O(n)$。

## 代码

```go
func threeSum(nums []int) [][]int {
    var ans [][]int
    n := len(nums)
    sort.Ints(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, n-1
        for l < r {
            s := nums[i] + nums[l] + nums[r]
            if s == 0 {
                ans = append(ans, []int{nums[i], nums[l], nums[r]})
                lv, rv := nums[l], nums[r]
                for l < r && nums[l] == lv {
                    l++
                }
                for l < r && nums[r] == rv {
                    r--
                }
            } else if s < 0 {
                l++
            } else {
                r--
            }
        }
    }
    return ans
}
```



